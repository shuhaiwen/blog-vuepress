---
title: 如何把函数存进容器中
date: 2019-06-05
sidebarDepth: 2
tags:
 - 函数
 - Lambda
categories:
 - C++
---
# 如何把函数存进容器中
- [如何把函数存进容器中](#如何把函数存进容器中)
	- [1.针对函数声明函数指针](#1针对函数声明函数指针)
	- [2.定义容器类型](#2定义容器类型)
	- [3.将函数名或lambda表达式存入容器](#3将函数名或lambda表达式存入容器)
	- [4.使用容器类函数](#4使用容器类函数)
	- [完整测试代码](#完整测试代码)
## 1.针对函数声明函数指针
作用：函数指针是用来作为容器的模板类型
- 假设要定义的函数如下
```
string* fun1(int)
{
	return new string("fun1");
}
```
- 对应函数指针声明如下
```
typedef string* (*pf)(int);
```
## 2.定义容器类型
注意：容器是函数指针类型
```
//向量类型
vector<pf> v;
//map类型
map<string, pf> mpf;
```
## 3.将函数名或lambda表达式存入容器
- map插入函数方法
```
//map中插入函数
mpf.insert(make_pair("1", fun1));
//map中插入lambda表达式
mpf.insert(make_pair("3", [](int)->string* {return new string("fun3"); }));
```
- vector插入函数方法
```
v.push_back(fun1);
v.push_back([](int)->string* {return new string("fun3"); });
```
## 4.使用容器类函数
- map中函数使用
```
	if (it != mpf.end)
	{
		string* pstr = it->second(1);
		delete pstr;
	}
```
-vector中函数使用
```
v[0](1);
```
------------
## 完整测试代码
```
#include <map>
#include <vector>
#include <string>
using namespace std;
typedef string* (*pf)(int);
vector<pf> v;
map<string, pf> mpf;

string* fun1(int)
{
	return new string("fun1");
}
string* fun2(int)
{
	return new string("fun2");
}
int setFun()
{
	v.push_back(fun1);
	v.push_back([](int)->string* {return new string("fun3"); });
	mpf.insert(make_pair("1", fun1));
	mpf.insert(make_pair("2", fun2));
	mpf.insert(make_pair("3", [](int)->string* {return new string("fun3"); }));
	return 1;
}

int main(int argc, char* argv[])
{
	setFun();
	map<string, pf>::iterator it= mpf.find("3");
	if (it != mpf.end)
	{
		string* pstr = it->second(1);
		delete pstr;
	}
	v[0](1);
	
}
```