# 类中成员变量为类自身

*类中成员变量为类自身时怎么写？*
## 1.指针，智能指针可以，对象不可以
**先看以下代码，一般成员声明情况**
```
class A
{
public:
	A();
	~A();
	A* m_pa; //正常
	A m_a;   //error:uses 'B', which is being define   
	shared_ptr<A> m_spa; //正常
}；
```
**解释：**
1. A m_a;不能通过编译，由错误信息可知，m_a实例化时类A正在定义中（即还没有定义），编译器无法知道类A占多少空间，因此不能编译通过。
2. A* m_pa；和 shared_ptr&lt;A&gt; m_spa; 能正常通过编译，因为m_pa是指针存的是地址，只占4字节大小，可以明确确定。

## 2.指针和智能指针怎么赋值？
1. 不能在对象未生成时执行对象的赋值操作
```
class A
{
public:
	A(){m_pa = new A;}
	A(int){}
	A(char) { init(); }
	~A();
	A* m_pa;
	shared_ptr<A> m_spa;
	void init() {
		m_pa = new A;
		m_spa.reset(m_pa);
	}
};

A a1; //error调用A();
A a2(2);//正常;
A a2('a');//error调用A(char);
a2.init();//正常
```
**解释**
1. A a1；会报错是因为A调用构造A()时，执行了语句m_pa = new A;而此时A的大小未知new多少内存无法确定，故报错；
2. A a2(2); 正常执行，因为他执行了构造A(int){}，未对m_pa操作；
3. A a2('a');会报错是因为构造A(char)间接调用对m_pa的赋值操作，理由与1一样；
4. a2.init();正常执行是因为此时A的大小已知，可以执行赋值操作
5. 智能指针遵循指针一样的原则

*总结：指针成员不能在类实例化阶段直接或间接进行操作*

