---
title: 类设计陷阱
date: 2020-08-19
sidebarDepth: 2
tags:
 - Class
categories:
 - C++
---

# 类设计陷阱

## 类成员是一个基类指针，深拷贝避免丢失子类数据
```c++
class A
{
public:
    virtual ~A(){}
public:
    string str_A;
};
class B :public A
{
public:
    string str_B;
};
class C
{
public:
    C() :m_a(nullptr) 
    {

    }
    C(const C& in)
    {
        if (in.m_a != nullptr)
        {
            m_a = new A();
            *m_a = *in.m_a;
        }
        else
           m_a = nullptr; 
        
    }
    C& operator=(const C& in)
    {
        if (&in == this)
            return *this;
        if (m_a != nullptr)
            delete m_a;
        if (in.m_a != nullptr)
        {
            m_a = new A();
            *m_a = *in.m_a;
        }
        else
            m_a = nullptr; 
        return *this;
    }
public:
    A* m_a;
};
```
上面例子中看似很完美，对C中的指针m_a进行了深拷贝，然而m_a失去了对子类的数据拷贝。当m_a是B指针赋给A指针时，这时拷贝构造和赋值运算符中 `*m_a = *in.m_a;`只会去调A的赋值运算符，而不会去调B的，这样，m_a中B数据就丢失了。下面是解决方法。
```c++
class C
{
public:
    C() :m_a(nullptr) 
    {

    }
    C(const C& in)
    {
        if (in.m_a != nullptr)
        {
            if (dynamic_cast<B*>(in.m_a))
            {
                B* pb = new B(*dynamic_cast<B*>(in.m_a));
                m_a = pb;
            }
            else
            {
                m_a = new A;
                *m_a = *in.m_a;
            }
            /*  m_a = new A();
              *m_a = *in.m_a;*/
        }
        else
            m_a = nullptr;
       
    }
    C& operator=(const C& in)
    {
        if (&in == this)
            return *this;
        if (m_a != nullptr)
            delete m_a;
        if (in.m_a != nullptr)
        {
            if (dynamic_cast<B*>(in.m_a))
            {
                B* pb = new B(*dynamic_cast<B*>(in.m_a));
                m_a = pb;
            }
            else
            {
                m_a = new A;
                *m_a = *in.m_a;
            }
            /* m_a = new A();
             *m_a = *in.m_a;*/
        }
        else
            m_a = nullptr;
        
        return *this;
    }
    ~C()
    {
        if (m_a != nullptr)
        {
            delete m_a;
            m_a = nullptr;
        }
    }
public:
    A* m_a;
};
```