---
title: 类设计陷阱
date: 2020-08-19
sidebarDepth: 2
tags:
 - Class
categories:
 - C++
---

# 类设计陷阱

## 1.类成员是一个基类指针，深拷贝避免丢失子类数据
```c++
class A
{
public:
    virtual ~A(){}
public:
    string str_A;
};
class B :public A
{
public:
    string str_B;
};
class C
{
public:
    C() :m_a(nullptr) 
    {

    }
    C(const C& in)
    {
        if (in.m_a != nullptr)
        {
            m_a = new A();
            *m_a = *in.m_a;
        }
        else
           m_a = nullptr; 
        
    }
    C& operator=(const C& in)
    {
        if (&in == this)
            return *this;
        if (m_a != nullptr)
            delete m_a;
        if (in.m_a != nullptr)
        {
            m_a = new A();
            *m_a = *in.m_a;
        }
        else
            m_a = nullptr; 
        return *this;
    }
public:
    A* m_a;
};
```
- 问题分析：上面例子中看似很完美，对C中的指针m_a进行了深拷贝，然而m_a失去了对子类的数据拷贝。当m_a是B指针赋给A指针时，这时拷贝构造和赋值运算符中 `*m_a = *in.m_a;`只会去调A的赋值运算符，而不会去调B的，这样，m_a中B数据就丢失了。
- 解决方法：通过static_cast或dynamic_cast判断具体子类类型,在对子类赋值（调用子类的赋值运算符）。
```c++
class C
{
public:
    C() :m_a(nullptr) 
    {

    }
    C(const C& in)
    {
        if (in.m_a != nullptr)
        {
            if (dynamic_cast<B*>(in.m_a))
            {
                B* pb = new B(*dynamic_cast<B*>(in.m_a));
                m_a = pb;
            }
            else
            {
                m_a = new A;
                *m_a = *in.m_a;
            }
            /*  m_a = new A();
              *m_a = *in.m_a;*/
        }
        else
            m_a = nullptr;
       
    }
    C& operator=(const C& in)
    {
        if (&in == this)
            return *this;
        if (m_a != nullptr)
            delete m_a;
        if (in.m_a != nullptr)
        {
            if (dynamic_cast<B*>(in.m_a))
            {
                B* pb = new B(*dynamic_cast<B*>(in.m_a));
                m_a = pb;
            }
            else
            {
                m_a = new A;
                *m_a = *in.m_a;
            }
            /* m_a = new A();
             *m_a = *in.m_a;*/
        }
        else
            m_a = nullptr;
        
        return *this;
    }
    ~C()
    {
        if (m_a != nullptr)
        {
            delete m_a;
            m_a = nullptr;
        }
    }
public:
    A* m_a;
};
```

## 2.类成员指针变量设计成私有，避免疏忽导致的内存泄漏
```c++
class A
{

};
class B
{
public:
    B() :m_a(nullptr) {}
    ~B() 
    {
        if (m_a != nullptr)
        {
            delete m_a;
            m_a = nullptr;
        }
    }
public:
    A* m_a;
};
int main()
{
    B b;
    {
        A* a1 = new A;
        b.m_a = a1;
    }
    {
        A* a2 = new A;
        b.m_a = a2;
    }
  
}
```
- 问题分析：上面B类定义看似完美，B生命周期结束自动删除m_a内存,但不正当的给m_a赋值导致了意外的内存泄漏。main函数中a1首先赋给了b.m_a,意图将a1的控制权交给b，确实b接管了a1，当b生命周期结束也可以通过析构删除a1指针,当a2又赋给b.m_a时，m_a痛快的结束了a2，从而放弃了a1的控制权,使a1内存泄漏。
- 解决方法：将成员指针设为私有，访问通过成员函数。
```c++
class A
{

};
class B
{
public:
    B() :m_a(nullptr) {}
    ~B()
    {
        if (m_a != nullptr)
        {
            delete m_a;
            m_a = nullptr;
        }
    }
    void setValue(A* a)
    {
        if (m_a != nullptr)
        {
            delete m_a;
            m_a = nullptr;
        }
        m_a = a;
    }
    A* getValue()
    {
        return m_a;
    }
private:
    A* m_a;
};
int main()
{
    B b;
    {
        A* a1 = new A;
        b.setValue(a1);
    }
    {
        A* a2 = new A;
        b.setValue(a2);
    }
   
}
```