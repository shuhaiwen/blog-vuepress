---
title: specifier
date: 2020-12-23
sidebarDepth: 2
tags:
 - specifier
categories:
 - C++
---
- [说明符](#说明符)
  - [`final`](#final)
  - [`override `](#override-)
  - [`alignas`和`alignof`](#alignas和alignof)
# 说明符
## `final`
- 功能：
  - 限制类**虚函数**不能在派生类中重写
  - 限制类不能被继承
- 示例
```c
struct Base
{
    virtual void foo();
};
 
struct A : Base
{
    void foo() final; // Base::foo is overridden and A::foo is the final override
    void bar() final; // Error: bar cannot be final as it is non-virtual
};
 
struct B final : A // struct B is final
{
    void foo() override; // Error: foo cannot be overridden as it is final in A
};
 
struct C : B // Error: B is final
{
};
```
## `override `
- 功能：指示类**虚函数**重写自基类**虚函数**
- 示例
```c
struct A
{
    virtual void foo();
    void bar();
};
struct B : A
{
    void foo() const override; // Error: B::foo does not override A::foo
                               // (signature mismatch)
    void foo() override; // OK: B::foo overrides A::foo
    void bar() override; // Error: A::bar is not virtual
};
```
## `alignas`和`alignof`
- 功能：
  - `alignas`指定内存对齐字节数
  - `alignof`计算内存对齐字节数(注：alignof不是说明符，是运算符)
- 示例
```c
struct alignas(128) G1 {
	float f;
};
struct G2
{
	char c1;
	G1 g;
	char c2;
};
int main()
{
	printf("sizeof(G1)=%d  alignof(G1)=%d\n", sizeof(G1), alignof(G1));
	printf("sizeof(G2)=%d  alignof(G2)=%d\n", sizeof(G2), alignof(G2));
	return 0;
}
//输出结果
//sizeof(G1)=128  alignof(G1)=128
//sizeof(G2)=384  alignof(G2)=128
```
- 上例中G1和G2结构的内存布局
```
1>class G1	size(128):
1>	+---
1> 0	| f
1>	+---
1>class G2	size(384):
1>	+---
1> 0	| c1
1>  	| <alignment member> (size=127)
1>128	| G1 g
1>256	| c2
1>  	| <alignment member> (size=127)
1>	+---
```